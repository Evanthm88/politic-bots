# Politic Bots

Tools and algorithms to analyze Paraguayan Tweets in times of elections. As part of the toolbox it is included an algorithm that identify Twitter bot accounts based on a series of heuristics.


## Bot Detector

Algorithm to detect Twitter bots. Given a user handle, it returns the probability of the user of being a bot. The algorithm is based on 18 heuristics, which are described below.

### Heuristic: Fake Handlers

Heuristic that allows identifying user names that contain a random string of numbers and letters or that are similar to user names used by public figures, for example @maritoabdo (true) --- current president of Paraguay---, @marioabdojunior (fake).

#### Implementation

##### Verification of similarity of one account with others

A set consisting of trustworthy accounts was created based on the number of followers of the account or if this account is verified.
With this set defined and saved in the BD, the algorithm proceeds to evaluate the similarity of the account that we wish to analyze with all the trustworthy accounts.
If the account belongs to the set of trustworthy accounts, the degree of similarity with any other will no longer be analyzed. If it is not, it will proceed to verify if the analyzed account is a derivative of a reliable account but with the suffix "junior" or "jr", in that case the probability that it is a false account will increase.
If the above cases are not applied, we proceed to compare the analyzed account ---screen_name and name--- with the trustworthy accounts using the bigram algorithm.


##### Verification of the user's name looking for random strings of numbers or letters

###### Verification of random numerical strings in an account

The numbers that have the screen_name of the account that is analyzed are extracted. If the account has many strings of numbers in the name, it is considered that the account may be false. Then look for possible "meanings" of such numbers as for example: year of creation of the account or possible date of birth --- in different formats ---.

###### Verification of the consonant-vowel relationship 

The number of vowels and consonants of screen_name and name is counted, and it is estimated that if the number of consonants is more than three times the vowels, the word probably does not make sense and maybe are random letters.

###### Verification of quantity of strings of letters

The screen_name and name are separated into strings only consisting of letters, if you have more than one string there are numbers or symbols in between could be a random name.

### Heuristic: Fake Promoter

Heuristic that identifies accounts that are promotioning other accounts exhibiting bot-like behaviour.

#### Preparation

This heuristic uses a db structure that has stored, for each user, its bot_detector_pbb(1) and, for each user interacted by the former, its screen name and bot_detector_pbb.
Before doing any computations, it fetches a sample of one(2) user document from the database, and if it already has the attribute 'bot_detector_pbb', it is assumed that it and all the user documents have the described structure. If it doesn't, its and its interacted users' bot_detector_pbbs are calculated and stored.
Since performing the preparations for this computations for every user may imply doing an extra computation for every user that she/he started an interaction with, an upper limit is set on the number of the interacted users that are going to be taken into account for the update process (NUM_INTERACTED_USERS). It can be set in the 'fake_promoter.py' file, 'modify_db' function.
In the same file and function, the number of documents to be updated can also be set (NUM_USERS). This in case it is desired to update the db in multiple passes. (Note that it's not the same constant than that of the 'bot_detector.py' file).

#### Implementation

The heuristic consists of evaluating the interactions (RTs, Quotes, Mentions, etc.) generated by the user being analyzed and doing some mathematical computations about them.
Since performing the preparations for this computations for every user may imply doing an extra computation for every user that she/he started an interaction with, and since not all interacted users may be stored in the document for each user, an upper limit is set on the number of the interacted users that are going to be taken into account for the computations (NUM_INTERACTED_USERS). It can be set in the 'bot_detector.py' file. Note that it's not the same constant than that of the 'fake_promoter.py' file, and it cannot be greater than the maximum number of interacted users stored in the db for each user. When describing the heuristic, this detail is ignored for simplicity purposes, but this must be taken into account when executing the script.

For illustrating how the heuristic works, let's take for example the user CESARSANCHEZ533.

Assume that he's the user being analyzed.
First, the interactions and users interacted by him are fetched, using the 'NetworkAnalyzer' class from the 'network_analysis' module(3). The results are better if the synthesis of the interactions of a user is ordered decreasingly by the number of interactions started with them, so its iterated in this order.
Also the synthesis of the interacted users with the bot_detector_pbb of each one of them is fetched.
The exact next steps depends on the specific method of the heuristic, and are described below. For now suffice it say that a score is calculated, and if it trespassess a Threshold, then the heuristic returns 1. If not, it returns 0.

There are two approaches and four different methods for computing the value of the heuristic -the score-. All of them implemented, and one can switch between one and another by setting the constant FAKE_PROMOTER_HEUR (in the method 'compute_bot_probability') to the number corresponding to the desired heuristic.

##### Approach Number 1

The main idea of this approach is to compute the number of interactions with users with a bot_detector_pbb higher than some minimum value (BOT_DET_PBB_THRS), and what fraction of the total number of interactions it represents.

###### Method 0

'Filter' the accounts by its bot_detector_pbb, selecting only those that are greater than a minimum (BOT_DET_PBB_THRS).
Compute the total number of interactions started by the analyzed user (in the example, CESARSANCHEZ533) with the filtered users.
Evaluate if this number is greater than some threshold(4) (SCORE_TOP_INTRCTNS_THRESHOLD), and return 1 if it is. Otherwise return 0.
Then divide over the total number of interactions of the user to get the percentage of the total that these interactions represents, and evaluate them against another threshold, and do the same as before.

##### Approach Number 2
Compute the average bot_detector_pbbs of the users interacted (or interacted users) by the user being analyzed. The methods differ in what they use as weights for the averages.

###### Method 1
Compute the average bot_detector_pbb of the interacted users. Evaluate against some threshold considered normal. If it's greater, return 1, else return 0.

###### Method 2
Compute the average bot_detector_pbb of the interacted users.
Compute also, for each interacted user, what fractions of the total represents the number of interactions with him, and use that as the weight for each bot_detector_pbb. 
Then proceed as before.

###### Method 3
Compute the average bot_detector_pbb of the interacted users.
Compute also, for each interacted user, what fractions of the interactions started with the top NUM_INTERACTED_USERS interacted users' represents the number of interactions with him, and use that as the weight for each bot_detector_pbb. 
Then proceed as before.

#### Footnotes:
(1) The result of executing the 'compute_bot_probability' method over the desired user, but without considering the present heuristic. This is controled with the 'promotion_heur_flag' flag.
(2) Provisorily. Perhaps a larger sample could be fetched.
(3) Hence, the interactions types considered in the heuristic (RTs, Quotes, Mentions, etc.) are the same that those considered in the 'network_analysis' module.
(4) The determination of this value (and the other thresholds) was done somewhat arbitrarily. What it indicates is how many interactions started with users with a bot_detector_pbb greater than BOT_DET_PBB_THRS is considered normal.
